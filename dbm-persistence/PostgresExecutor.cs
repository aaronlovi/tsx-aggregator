using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Npgsql;

namespace dbm_persistence;

public interface IPostgresStatement {
    Task<DbStmtResult> Execute(NpgsqlConnection conn, CancellationToken ct);
}

public class PostgresExecutor : IDisposable {
    private readonly ILogger<PostgresExecutor> _logger;
    private readonly int _maxRetries = 5; // 0 = unlimited
    private readonly int _retryDelayMilliseconds = 1000; // 0 = no delay
    private readonly int _maxConcurrentStatements = 20;
    private readonly string _connectionString;

    private readonly SemaphoreSlim _connectionLimiter;
    private bool _disposedValue;

    public PostgresExecutor(IServiceProvider svp) {
        IConfiguration config = svp.GetRequiredService<IConfiguration>();
        _connectionString = config.GetConnectionString("tsx-scraper") ?? string.Empty;
        if (string.IsNullOrEmpty(_connectionString))
            throw new InvalidOperationException("Connection string is empty");

        _logger = svp.GetRequiredService<ILogger<PostgresExecutor>>();
        _logger.LogInformation("Persistence is enabled");

        Parse("MaxRetries", out _maxRetries);
        Parse("RetryDelayMilliseconds", out _retryDelayMilliseconds);
        Parse("MaxConcurrentStatements", out _maxConcurrentStatements);

        _logger.LogInformation("DatabaseManager settings: (maxRetries:{MaxRetries}, retryDelayMilliseconds: {RetryDelayMilliseconds}, maxConcurrentStatements: {MaxConcurrentStatements})",
            _maxRetries, _retryDelayMilliseconds, _maxConcurrentStatements);

        _connectionLimiter = new(_maxConcurrentStatements);

        // Local helper methods

        void Parse(string paramName, out int paramValue) {
            if (!int.TryParse(config[paramName], out paramValue))
                _logger.LogWarning("Failed to parse {ParamName}, using default value {ParamValue}", paramName, paramValue);
        }
    }

    public bool IsEnabled => !string.IsNullOrEmpty(_connectionString);

    public async Task<DbStmtResult> Execute(IPostgresStatement stmt, CancellationToken ct) {
        ArgumentNullException.ThrowIfNull(stmt, nameof(stmt));

        try {
            using var limiter = new SemaphoreLocker(_connectionLimiter);
            await limiter.Acquire(ct);

            using var connection = new NpgsqlConnection(_connectionString); // Does not throw
            await connection.OpenAsync(ct);
            return await stmt.Execute(connection, ct);
        }
        catch (NpgsqlException ex) {
            _logger.LogError(ex, "Error in Execute");
            throw;
        }
    }

    public async Task<DbStmtResult> ExecuteWithRetry(IPostgresStatement stmt, CancellationToken ct, int? overrideMaxRetries = null) {
        int effectiveMaxRetries = overrideMaxRetries ?? _maxRetries;
        if (effectiveMaxRetries == 0)
            effectiveMaxRetries = int.MaxValue;

        for (int retries = 0; retries < effectiveMaxRetries; retries++) {
            try {
                return await Execute(stmt, ct);
            }
            catch (PostgresException) {
                // generated by the database server, do not retry
                throw;
            }
            catch (NpgsqlException) {
                await Task.Delay(TimeSpan.FromMilliseconds(_retryDelayMilliseconds));
                // continue to retry
            }

            // The following is implicit, and occurs on cancellation
            //catch (OperationCanceledException) {
            //    throw;
            //}
        }

        return DbStmtResult.StatementFailure("Too many retries");
    }

    #region IDisposable implementation

    protected virtual void Dispose(bool disposing) {
        if (!_disposedValue) {
            if (disposing)
                _connectionLimiter.Dispose();

            // TODO: free unmanaged resources (unmanaged objects) and override finalizer
            // TODO: set large fields to null
            _disposedValue = true;
        }
    }

    public void Dispose() {
        // Do not change this code. Pub cleanup code in 'Dispose(bool disposing)' method
        Dispose(disposing: true);
        GC.SuppressFinalize(this);
    }

    #endregion
}

public sealed class SemaphoreLocker : IDisposable {
    private readonly SemaphoreSlim _semaphore;
    private bool _acquired;
    public SemaphoreLocker(SemaphoreSlim semaphore) {
        _semaphore = semaphore;
    }

    public async Task Acquire(CancellationToken ct) {
        await _semaphore.WaitAsync(ct);
        _acquired = true;
    }

    public void Dispose() {
        if (_acquired) {
            _ = _semaphore.Release();
            _acquired = false;
        }
    }
}
